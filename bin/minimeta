#!/usr/bin/env perl

use strict;
use warnings;
use 5.012;
use autodie;

use BioX::Seq::Fetch;
use BioX::Seq::Stream;
use Cwd qw/abs_path getcwd/;
use File::Basename qw/basename/;
use File::Copy qw/copy/;
use File::Temp;
use Getopt::Long;
use IPC::Cmd qw/can_run run/;
use Pod::Usage;
use Time::Seconds;

our $VERSION = 0.008;
use constant PROGRAM => 'minimeta';

#-inputs---------------------------------------------------------------------#
my $fi_reads;
my $fi_consensus;
my $fi_homopolish;
#-outputs--------------------------------------------------------------------#
my $fo_consensus;
#-knobs----------------------------------------------------------------------#
my $threads  = 1;
my $n_racon  = 0;
my $n_medaka = 1;
my $quiet    = 0;
my $min_cov  = 2;
my $min_len  = 1;
my $hp_model = 'R9.4.pkl';
my $med_model;
my $mask_below;
my $split;
my $only_split_at_hp = 0;
my $minimizer_cutoff;
my $reduce = 0;
my $min_ident = 0.8;
my $shuffle = 1;
my $deterministic = 0;
my $trim_polyN = 0;
my $polyN_len = 30;

GetOptions(
    #-inputs-----------------------------------------------------------------#
    'in=s'         => \$fi_reads,
    'assembly=s'   => \$fi_consensus,
    'homopolish=s' => \$fi_homopolish,
    #-outputs----------------------------------------------------------------#
    'out=s' => \$fo_consensus,
    #-knobs------------------------------------------------------------------#
    'threads=i'          => \$threads,
    'n_racon=i'          => \$n_racon,
    'n_medaka=i'         => \$n_medaka,
    'min_cov=i'          => \$min_cov,
    'min_len=i'          => \$min_len,
    'mask_below=f'       => \$mask_below,
    'split!'             => \$split,
    'hp_model=s'         => \$hp_model,
    'medaka_model=s'     => \$med_model,
    'only_split_at_hp'   => \$only_split_at_hp,
    'minimizer_cutoff=i' => \$minimizer_cutoff,
    'reduce'             => \$reduce,
    'min_ident=f'        => \$min_ident,
    'shuffle!'           => \$shuffle,
    'trim_polyN!'        => \$trim_polyN,
    'deterministic'      => \$deterministic,
    'quiet'              => \$quiet,
    'help'               => sub{ pod2usage(-verbose => 2, -exitval => 0); },
    'version'            => sub{ say 'This is ',PROGRAM,' v', $VERSION; exit },
) or pod2usage( -verbose => 1);

# check for required software
my $MINIMAP2 = can_run('minimap2')
    // die "Minimap2 is required but not found\n";

my $SEQKIT = can_run('seqkit');
if ($shuffle && ! defined $SEQKIT) {
    die "SeqKit is required for shuffling but not found\n";
}

my $CUTADAPT = can_run('cutadapt');
if ($trim_polyN && ! defined $CUTADAPT) {
    die "Cutadapt is required for trimming but not found\n";
}

my $MINIASM = can_run('miniasm');
if (! defined $fi_consensus && ! defined $MINIASM) {
    die "Miniasm is required but not found\n";
}

my $RACON = can_run('racon');
if ($n_racon > 0 && ! defined $RACON) {
    die "Racon is required for polishing but not found\n";
}

my $MEDAKA = can_run('medaka_consensus');
if ($n_medaka > 0 && ! defined $MEDAKA) {
    die "Medaka is required for polishing but not found\n";
}

my $SAMTOOLS = can_run('samtools');
if (defined $mask_below && ! defined $SAMTOOLS) {
    die "Samtools is required for masking/splitting but not found\n";
}

my $BEDTOOLS = can_run('bedtools');
if (defined $mask_below && ! defined $BEDTOOLS) {
    die "Bedtools is required for masking/splitting but not found\n";
}

my $HOMOPOLISH = can_run('homopolish');
if (defined $fi_homopolish && ! defined $HOMOPOLISH) {
    die "Homopolish is required for polishing but not found\n";
}

my $REDUNDANS = can_run('redundans.py');
if ($reduce && ! defined $REDUNDANS) {
    die "Redundans is required for reducing but not found\n";
}


# globals

die "Must define existing input file (--in)\n"
    if (! defined $fi_reads || ! -r $fi_reads);
$fi_reads = abs_path($fi_reads);

if (defined $fi_consensus) {
    die "Input assembly not found or readable\n"
        if (! -r $fi_consensus);
    $fi_consensus = abs_path($fi_consensus);
}

if (defined $fi_homopolish) {
    die "Homopolish reference not found or readable\n"
        if (! -r $fi_homopolish);
    $fi_homopolish = abs_path($fi_homopolish);
}

if (defined $fo_consensus) {
    $fo_consensus = abs_path($fo_consensus);
}

# work in scratch space
my $init_dir = abs_path(getcwd());
my $in_base = basename($fi_reads);
my $wd =  File::Temp->newdir(CLEANUP => 1);
chdir $wd;

if ($shuffle) {
    plog( 'shuffle', 'Shuffle input reads' );
    my $ts = time;
    shuffle( $fi_reads, $in_base );
    my $el = Time::Seconds->new(time - $ts)->pretty;
    plog( 'shuffle', "Shuffle took $el" );


}
else {
    symlink $fi_reads, $in_base;
}

if ($trim_polyN) {
    plog( 'trim', 'Trim polyN stretches' );
    my $ts = time;
    my $report = trim_polyN( $in_base, 'trimmed.fq' );
    my $el = Time::Seconds->new(time - $ts)->pretty;
    plog( 'trim', "Trimming took $el" );
    plog( 'trim', sprintf(
        "Trimmed %0.1f%% of reads; Discarded %0.1f%% reads; Discarded %0.1f%% bases",
        $report->{'w/adapters'} / $report->{in_reads} * 100,
        ($report->{in_reads} - $report->{out_reads})/$report->{in_reads}*100,
        ($report->{in_bp} - $report->{out_bp})/$report->{out_bp}*100,
    ) );
    unlink $in_base
        if (abs_path($in_base) ne abs_path($fi_reads));
    $in_base = 'trimmed.fq';
}

my $curr_cons = 'init.fa';

# initial assembly
if (defined $fi_consensus) {
    copy $fi_consensus, $curr_cons;
    plog( 'assembly', "Using provided assembly" );
}
else {
    plog( 'assembly', 'Initial assembly with miniasm' );
    my $ts = time;
    map_ava( $in_base, 'init.paf' );
    miniasm( $in_base, 'init.paf', $curr_cons );
    my $n = n_seqs($curr_cons);
    my $el = Time::Seconds->new(time - $ts)->pretty;
    plog( 'assembly', "Assembly took $el" );
    plog( 'assembly', "Assembled $n contigs" );
}

# bail out gracefully if initial assembly is empty
if (! -s $curr_cons) {
    plog( 'assembly', "Initial assembly empty, skipping polishing" );
    if (defined $fo_consensus) {
        copy $curr_cons, $fo_consensus;
    }
    chdir $init_dir;
    exit;
}

# racon polishing
plog( 'racon', "Polishing with racon ($n_racon rounds total)" );
for my $i (1..$n_racon) {
    my $new_cons = "rc$i.fa";

    my $ts = time;
    polish_racon( $in_base, $curr_cons, $new_cons);
    my $el = Time::Seconds->new(time - $ts)->pretty;
    plog( 'racon', "Round took $el"  );

    $curr_cons = $new_cons;
}

if (defined $fi_homopolish) {

    # homopolishing
    plog( 'homopolish', "Polishing with homopolish" );
    my $new_cons = "hp.fa";

    my $ts = time;
    homopolish( $fi_homopolish, $curr_cons, $new_cons);
    my $el = Time::Seconds->new(time - $ts)->pretty;
    plog( 'homopolish', "Took $el" );

    $curr_cons = $new_cons;

}

# medaka polishing
plog( 'medaka', "Polishing with medaka ($n_medaka rounds total)" );
for my $i (1..$n_medaka) {

    my $new_cons = "md$i.fa";

    my $ts = time;
    polish_medaka( $in_base, $curr_cons, $new_cons);
    my $el = Time::Seconds->new(time - $ts)->pretty;
    plog( 'medaka', "Round took $el" );

    $curr_cons = $new_cons;
}

if (defined $mask_below) {

    my ($v1, $v2) = defined $split
        ? ('split', 'Splitting')
        : ('mask', 'Masking');
    plog( $v1, "$v2 at regions with coverage below $mask_below" );
    my $new_cons = "mask.fa";

    my $ts = time;
    my $n_start = n_seqs($curr_cons);
    mask_below($in_base, $curr_cons, $new_cons, $mask_below, $split);
    my $n_end = n_seqs($new_cons);
    my $n_splits = $n_end - $n_start;
    my $el = Time::Seconds->new(time - $ts)->pretty;
    plog( $v1, "$v2 took $el" );
    if (defined $split) {
        plog( 'split', "$n_splits splits made" );
    }

    $curr_cons = $new_cons;

}

# Redundans reduction
if ($reduce) {

    plog( 'reduce', "Removing redundant contigs with identity above $min_ident" );
    my $new_cons = "reduced.fa";

    my $ts = time;
    my $n_start = n_seqs($curr_cons);
    redundans($curr_cons, $new_cons, $min_ident);
    my $n_end = n_seqs($new_cons);
    my $n_filt = $n_start - $n_end;
    my $el = Time::Seconds->new(time - $ts)->pretty;
    plog( 'reduce', "Reduction took $el" );
    plog( 'reduce', "$n_filt contigs removed" );

    $curr_cons = $new_cons;

}

#always run this, and run it last, since we rename the contigs as well
if (1) {

    plog( 'filter', "Filtering contigs shorter than $min_len" );
    my $new_cons = "filtered.fa";

    my $ts = time;
    my $n_start = n_seqs($curr_cons);
    filter_short($curr_cons, $new_cons, $min_len);
    my $n_end = n_seqs($new_cons);
    my $n_filt = $n_start - $n_end;
    my $el = Time::Seconds->new(time - $ts)->pretty;
    plog( 'filter', "Filtering took $el" );
    plog( 'filter', "$n_filt contigs removed" );

    $curr_cons = $new_cons;

}

summarize_assembly($curr_cons);

# copy to final location
open my $in, '<', $curr_cons;
my $fh_out = \*STDOUT;
if (defined $fo_consensus) {
    open my $fh, '>', $fo_consensus;
    $fh_out = $fh;
}
while (my $line = <$in>) {
    print {$fh_out} $line;
}

chdir $init_dir;
exit;

# minimap2 -ax map-ont trim.fa trimmed.fq > rc.sam
# racon -m 8 -x -6 -g -8 -w 500 --no-trimming trimmed.fq rc.sam trim.fa > rc.fa

# minimap2 -x ava-ont trimmed.fq trimmed.fq > trim.paf
sub map_ava {
    
    my ($fi, $fo) = @_;

    my @fmax = ();
    if (defined $minimizer_cutoff) {
        push @fmax, '-f', $minimizer_cutoff;
    }
    my @cmd = (
        $MINIMAP2,
        '-t' => $threads,
        '-x' => 'ava-ont',
        '-o' => $fo,
        @fmax,
        $in_base,
        $in_base,
    );
    run( command => \@cmd )
        or die "Initial AVA mapping failed: $!";
}

sub mask_below {
    
    my ($fi_reads, $fi_cons, $fo_cons, $mask_below, $split) = @_;

    # map reads against existing consensus
    # minimap2 -ax map-ont trim.fa trimmed.fq > rc.sam
    my @cmd_mm = (
        $MINIMAP2,
        '-t' => $threads,
        '-a',
        '-x' => 'map-ont',
        '-o' => 'mask.sam',
        $fi_cons,
        $fi_reads,
    );
    run( command => \@cmd_mm )
        or die "consensus read mapping failed: $!";

    my @cmd_sort = (
        $SAMTOOLS,
        'sort',
        '--threads' => $threads,
        '-o' => 'sorted.bam',
        'mask.sam',
    );
    run( command => \@cmd_sort )
        or die "SAM sorting failed: $!";


    my @cmd_cov = (
        $BEDTOOLS,
        'genomecov',
        '-ibam' => 'sorted.bam',
        #'-split',
        '-bga',
    );
    my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf )
        = run( command => \@cmd_cov );
    die "Error running bedtools genomecov: $error_message"
        if (! $success);
    open my $bg, '>', 'coverage.bedgraph';
    print {$bg} buff_to_str($stdout_buf);
    close $bg;

    # fractional cutoff is interpreted as fraction of median depth,
    # so we need to calculate that here for each contig
    my $individual_cutoffs;
    if ($mask_below < 1 && $mask_below > 0) {

        # create contig interval BED, using sort order from bedgraph
        open my $chr_bed, '>', 'chrs.bed';
        my @order;
        open my $cov, '<', 'coverage.bedgraph';
        while (my $line = <$cov>) {
            chomp $line;
            my ($chr, @other) = split "\t", $line;
            push @order, $chr
            if (! scalar(@order) || $chr ne $order[-1]);
        }
        close $cov;
        
        my $p = BioX::Seq::Fetch->new($fi_cons);
        for my $chr (@order) {
            my $seq = $p->fetch_seq($chr)
                // die "Seq $chr missing in input";
            say {$chr_bed} join "\t",
                $seq->id,
                0,
                length($seq),
            ;
        }
        close $chr_bed;

        my @cmd_map = (
            $BEDTOOLS,
            'map',
            '-a' => 'chrs.bed',
            '-b' => 'coverage.bedgraph',
            '-c' => '4',
            '-o' => 'median',
        );
        my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf )
            = run( command => \@cmd_map );
        die "Error running bedtools map: $error_message"
            if (! $success);
        # this hack is necessary to process output by line; otherwise buffering can
        # cause incomplete lines to be processed
        my $stdout = join '', @{ $stdout_buf};
        open my $stream, '<', \$stdout;
        while (my $line = <$stream>) {
            chomp $line;
            my ($chr, $s, $e, $depth) = split "\t", $line;
            $individual_cutoffs->{$chr} = $depth * $mask_below;
        }
        close $stream;

    }

    my %split_points;
    my $mask;
    if (! $split) {
        open $mask, '>', 'mask.bed';
    }
    open my $stream, '<', 'coverage.bedgraph';
    while (my $line = <$stream>) {
        chomp $line;
        my @fields = split "\t", $line;
        my $cutoff = defined $individual_cutoffs
            ? ($individual_cutoffs->{ $fields[0] } // 0)
            : $mask_below;
        next if ($fields[3] >= $cutoff);
        if ($split) {
            push @{ $split_points{$fields[0]} }, [$fields[1]+1, $fields[2]];
        }
        else {
            say {$mask} $line;
        }
    }
    close $mask
    	if (defined $mask);
    close $stream;

    # Here we perform masking only
    if (! $split) {

        # mask consensus
        my @cmd_mask = (
            $BEDTOOLS,
            'maskfasta',
            '-fi' => $fi_cons,
            '-bed' => 'mask.bed',
            '-fo' => $fo_cons,
        );
        run( command => \@cmd_mask )
            or die "Error running bedtools maskfasta: $!";

    }

    # ... or we split the contigs
    else {

        open my $out, '>', $fo_cons;

        my $p = BioX::Seq::Stream->new($fi_cons);
        CHR:
        while (my $seq = $p->next_seq) {

            my $chr = $seq->id;
            my @points = defined $split_points{$chr}
                ? @{ $split_points{$chr} }
                : ();
            if ($only_split_at_hp) {
                my @new;
                my $win = 5;
                for my $p (@points) {
                    my $hp = 0;
                    for (@$p) {
                        my $l = $_ > $win ? $_-$win : 1;
                        my $r = length($seq) - $_ > $win ? $_+$win : length($seq);
                        my $s = $seq->range($l, $r);
                        ++$hp if ($s->seq =~ /(\w)(\1{3,})/);
                    }
                    push @new, $p if ($hp > 0);
                }
                @points = @new;
            }
            if (! scalar @points) {
                print {$out} $seq->as_fasta;
                next CHR;
            }
            my $i = 1;
            for my $p (@points) {
                if ($p->[0] >= $i) {
                    my $sub = $seq->range($i, $p->[0]-1);
                    my $l = length $sub;
            if ($l > 0) {
                        $sub->desc =~ s/\bLN:i:\d+\b/LN:i:$l/;
                        print {$out} $sub->as_fasta;
            }
                }
                $i = $p->[1] + 1;
            }
            if ($i <= length($seq)) {
                my $sub = $seq->range($i, length($seq));
                my $l = length $sub;
                if ($l > 0) {
                    $sub->desc =~ s/\bLN:i:\d+\b/LN:i:$l/;
                    print {$out} $sub->as_fasta;
                }
            }

        }
                
        close $out;
    }

}
    

sub miniasm {
    
    my ($fi_reads, $fi_paf, $fo) = @_;

    my @cmd = (
        $MINIASM,
        '-s' => '200',
        '-c' => $min_cov,
        '-e' => 1,
        '-I' => '0.2',
        '-f' => $fi_reads,
        $fi_paf,
    );
    #open my $stream, '-|', @cmd;
    my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf )
        = run( command => \@cmd );
    die "Error running miniasm: $error_message"
        if (! $success);

    # convert GFA to FASTA
    open my $out, '>', $fo;
    # this hack is necessary to process output by line; otherwise buffering can
    # cause incomplete lines to be processed
    my $stdout = join '', @{ $stdout_buf};
    open my $stream, '<', \$stdout;
    while (my $line = <$stream>) {
        chomp $line;
        my @fields = split "\t", $line;
        next if ($fields[0] ne 'S');
        print {$out} BioX::Seq->new(
            $fields[2],
            $fields[1],
            $fields[3],
        )->as_fasta;
    }
    close $out;
    close $stream;

}

sub polish_racon {
    
    my ($fi_reads, $fi_cons, $fo_cons) = @_;

    # map reads against existing consensus
    # minimap2 -ax map-ont trim.fa trimmed.fq > rc.sam
    my @cmd_mm = (
        $MINIMAP2,
        '-t' => $threads,
        '-a',
        '-x' => 'map-ont',
        '-o' => 'rc.sam',
        $fi_cons,
        $fi_reads,
    );
    run( command => \@cmd_mm )
        or die "consensus read mapping failed: $!";

    # call new consensus with Racon
    # racon -m 8 -x -6 -g -8 -w 500 --no-trimming trimmed.fq rc.sam trim.fa > rc.fa
    my @cmd_rc = (
        $RACON,
        '--threads'       => $threads,
        '--match'         => 8,
        '--mismatch'      => '-6',
        '--gap'           => '-8',
        '--window-length' => 500,
        '--no-trimming',
        $fi_reads,
        'rc.sam',
        $fi_cons
    );
    
    my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf )
        = run( command => \@cmd_rc );
    die "Error running racon: $error_message"
        if (! $success);

    open my $out, '>', $fo_cons;
    # this hack is necessary to process output by line; otherwise buffering can
    # cause incomplete lines to be processed
    my $stdout = join '', @{ $stdout_buf};
    open my $stream, '<', \$stdout;
    while (my $line = <$stream>) {
        print {$out} $line;
    }
    close $out;
    close $stream;

}

# medaka_consensus -i trimmed.fq -d rc2.fa -o polished
sub polish_medaka {

    my ($fi_reads, $fi_cons, $fo_cons) = @_;

    my @cmd = (
        $MEDAKA,
        '-t' => $threads,
        '-f',
        '-i' => $fi_reads,
        '-d' => $fi_cons,
        '-o' => 'polished',
    );
    if (defined $med_model) {
        push @cmd, '-m' => $med_model;
    }
    run( command => \@cmd )
        or die "Call to medaka failed: $!";

    # transfer annotations dropped by Medaka
    transfer_annots(
        $fi_cons,
        'polished/consensus.fasta',
        $fo_cons
    );

}

sub transfer_annots {

    my ($fn_old, $fn_new, $fn_out, $strip_suffix) = @_;

    open my $fh_out, '>', $fn_out;

    # read annotations from input contigs
    my %annots;
    my $p = BioX::Seq::Stream->new($fn_old);
    while (my $seq = $p->next_seq) {
        $annots{$seq->id} = $seq->desc // '';
    }
    # copy annotations to output contigs
    $p = BioX::Seq::Stream->new($fn_new);
    while (my $seq = $p->next_seq) {
        my $id = $seq->id;
        if (defined $strip_suffix) {
            $id =~ s/$strip_suffix$//;
            $seq->id = $id;
        }
        my $tags = $annots{$id}
            // die "Missing annotations for contig " . $id;
        my $l = length $seq;
        $tags =~ s/\bLN:i:\d+\b/LN:i:$l/;
        $seq->desc = join ' ',
            grep {defined $_ && length $_} $seq->desc, $tags;
        print {$fh_out} $seq->as_fasta;
    }

    close $fh_out;

}

sub shuffle {
    
    my ($fi_reads, $fo_reads) = @_;

    my $seed = $deterministic ? 22 : int(rand(999999));
    my @cmd = (
        $SEQKIT,
        'shuffle',
        '-s' => $seed,
        '-o' => $fo_reads,
        $fi_reads,
    );
    run( command => \@cmd )
        or die "shuffle failed: $!";

}
sub trim_polyN {
    
    my ($fi_reads, $fo_reads) = @_;

    my @cmd = (
        $CUTADAPT,
        '-b' => "A{$polyN_len}",
        '-b' => "T{$polyN_len}",
        '-b' => "G{$polyN_len}",
        '-b' => "C{$polyN_len}",
        '--times' => '50',
        '--minimum-length' => '100',
        '--report' => 'minimal',
        '-o' => $fo_reads,
        $fi_reads,
    );
    run( command => \@cmd )
        or die "shuffle failed: $!";
    my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf )
        = run( command => \@cmd );
    die "Error running cutadapt: $error_message"
        if (! $success);
    my $so = buff_to_str($stdout_buf);
    my ($k, $v, @other) = split /\n/, $so;
    my %report;
    @report{ split "\t", $k } = split "\t", $v;
    for my $field (
        'in_reads',
        'out_reads',
        'in_bp',
        'out_bp',
        'w/adapters'
    ) {
        die "Missing field $field in cutadapt report\n"
            if (! defined $report{$field});
    }
    return \%report;

}

sub filter_short {
    
    my ($fi_cons, $fo_cons, $min_len) = @_;

    my $p = BioX::Seq::Stream->new($fi_cons);
    my @final;
    while (my $seq = $p->next_seq) {
        next if (length $seq < $min_len);
        push @final, $seq;
    }

    my $padding = length (scalar @final - 1);
    my $i = 0; 
    open my $out, '>', $fo_cons;
    for my $ctg (sort {length($b) <=> length($a)} @final) {
        $ctg->id = sprintf "ctg_%0${padding}s", $i++;
        print {$out} $ctg->as_fasta;
    }
    close $out;

}

sub homopolish {
    
    my ($fi_ref, $fi_cons, $fo_cons) = @_;

    my @cmd_hp = (
        $HOMOPOLISH,
        'polish',
        '-a' => $fi_cons,
        '-l' => $fi_ref,
        '-m' => $hp_model,
        '--minimap_args' => 'map-ont',
        '-o' => 'hp',
    );
    run( command => \@cmd_hp )
        or die "homopolish failed: $!";

    my $basename = basename($fi_cons);
    $basename =~ s/\..*//;
    my $hp_out = "hp/${basename}_homopolished.fasta";
    die "Missing homopolish output file\n"
        if (! -e $hp_out);

    # transfer annotations dropped by homopolish
    transfer_annots(
        $fi_cons,
        $hp_out,
        $fo_cons,
        '_polish',
    );

}

sub redundans {

    my ($fi_cons, $fo_cons, $min_ident) = @_;

    my @cmd = (
        $REDUNDANS,
        '-t' => $threads,
        '--noscaffolding',
        '--nogapclosing',
        '--identity' => $min_ident,
        '-f' => $fi_cons,
        '-o' => 'reduced',
    );
    run( command => \@cmd )
        or die "Call to redundans failed: $!";

    # transfer annotations dropped by redundans
    transfer_annots(
        $fi_cons,
        'reduced/scaffolds.reduced.fa',
        $fo_cons
    );

}

sub plog {

    my ($unit, $msg) = @_;
    return if ($quiet);
    say STDERR "[mm::$unit] $msg";

}

sub buff_to_str {

    my ($buff, $fn) = @_;
    return join '', @{ $buff };

}

sub n_seqs {

    my ($fn) = @_;
    return scalar BioX::Seq::Fetch->new($fn)->ids;

}

sub summarize_assembly {

    my ($fn) = @_;

    my $len_total = 0;
    my $n_seqs = 0;
    my $max_len = 0;
    my $p = BioX::Seq::Stream->new($fn);
    while (my $seq = $p->next_seq) {
        my $l = length $seq;
    ++$n_seqs;
    $len_total += $l;
    $max_len = $l if ($l > $max_len);
    }
    plog(
        'final',
        sprintf(
            "Final assembly: %s contigs; %s total bp; %s bp longest contig",
            $n_seqs,
            $len_total,
            $max_len,
        )
    );

}

__END__

=head1 NAME

minimeta - assembler for long-read metagenomic/metatranscriptomic data sets

=head1 SYNOPSIS

minimeta --in <reads.fq> --out <consensus.fasta>

=head1 DESCRIPTION

Produces a polished consensus assembly from long-read sequencing data using
miniasm, racon, and medaka. Software settings are tuned for
metagenomic/metatranscriptomic assemblies of variable, sometimes low,
coverage.

=head1 PREREQUISITES

Requires the following non-core Perl libraries:

=over 1

=item BioX::Seq

=back

Additionally, the following external programs are required for one or more of
the optional processing modules (errors will be thrown for missing programs
only if that module is requested). All optional dependencies are available in
Bioconda.

=over 1

=item minimap2

=item miniasm

=item racon

=item medaka

=item samtools

=item bedtools

=item seqkit

=item redundans

=item cutadapt

=item homopolish

=back

=head1 OPTIONS

=head2 Input

=over 4

=item B<--in> I<filename>

Path to input reads in FASTx format (required)

=item B<--assembly> I<filename>

Path to existing assembly. If provided, assembly is skipped and only polishing
is performed (default: none).

=item B<--homopolish> I<filename>

Path to reference FASTA file used by homopolish. Providing this filename also
triggers polishing using homopolish (default: none).

=back

=head2 Output 

=over 4

=item B<--out> I<filename>

Path to write consensus sequence to (as FASTA) [default: STDOUT]

=back

=head2 Configuration 

=over 4

=item B<--min_cov> I<integer>

Minimum read coverage required by assembler to keep position (default: 2)

=item B<--min_len> I<integer>

Minimum contig length to keep (default: 1)

=item B<--mask_below> I<integer>

If given, final assembly positions with coverage depth below this value will
be hard masked with 'N' (default: off)

=item B<--split> I<float>

If given in conjunction with C<--mask_below>, splits contigs at masked regions
into smaller pieces. (default: off)

=item B<--only_split_at_hp>

If given in conjuction with C<--split>, only splits low coverage regions
if one or both junctions is at a homopolymer stretch
(default: off)

=item B<--threads> I<integer>

Number of processsing threads to use for mapping and polishing (default: 1)

=item B<--n_racon> I<integer>

Number of Racon polishing rounds to perform (default: 3)

=item B<--n_medaka> I<integer>

Number of Medaka polishing rounds to perform (default: 1)

=item B<--medaka_model> I<string>

Name of model to be used by medaka_consensus (based on basecalling model used
for data) (default: r941_min_high_g360)

=item B<--hp_model> I<string>

Name of model to be used by homopolish. Has no effect if B<--homopolish> not
used. (default: R9.4.pkl)

=item B<--noshuffle>

Don't randomly shuffle input reads prior to assembly (default: shuffle)

=item B<--trim_polyN>

Trim long poly-N stretches from reads prior to assembly (default: off)

=item B<--deterministic>

Use a fixed seed for random processes such as shuffling (default: off)

=item B<--reduce>

Apply a reduction algorithm to the pre-final assembly to remove redundant
contigs (i.e. contigs mostly or completely overlapping with identity above a
cutoff specified by B<--min_ident>. Currently this is done using Redundans,
which is required to be installed. (default: off)

=item B<--min_ident> I<float>

Minimum identity (0 to 1) between contigs required to remove shorter contig during
redundancy reduction. (default: 0.8)

=item B<--minimizer_cutoff> I<integer>

During all-vs-all mapping, discard minimizers occurring above this frequency.
This is the B<-f> parameter to minimap2, and can be useful with high-coverage
input datasets that may otherwise consume very large amounts of memory and
time. A value between 1000 and 10,000 may be useful in these cases. (default:
off)

=item B<--quiet>

Don't write status messages to STDERR

=item B<--help>

Print usage description and exit

=item B<--version>

Print software version and exit

=back

=head1 CAVEATS AND BUGS

Please submit bug reports to the issue tracker in the distribution repository.

=head1 AUTHOR

Jeremy Volkening (jeremy.volkening@base2bio.com)

=head1 LICENSE AND COPYRIGHT

Copyright 2021-23 Jeremy Volkening

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

