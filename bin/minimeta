#!/usr/bin/env perl

use strict;
use warnings;
use 5.012;
use autodie;

use BioX::Seq::Stream;
use Cwd qw/abs_path getcwd/;
use File::Basename qw/basename/;
use File::Copy qw/copy/;
use File::Temp;
use Getopt::Long;
use IPC::Cmd qw/can_run run/;
use Pod::Usage;

#-inputs---------------------------------------------------------------------#
my $fi_reads;
my $fi_consensus;
my $fi_homopolish;
#-outputs--------------------------------------------------------------------#
my $fo_consensus;
#-knobs----------------------------------------------------------------------#
my $threads  = 1;
my $n_racon  = 3;
my $n_medaka = 1;
my $quiet    = 0;
my $min_cov  = 2;
my $min_len  = 1;
my $hp_model = 'R9.4.pkl';
my $med_model;
my $mask_below;
my $split_below;
my $only_split_at_hp = 0;

my $PROGRAM = 'minimeta';
my $VERSION = 0.004;

GetOptions(

    #-inputs-----------------------------------------------------------------#
    'in=s'         => \$fi_reads,
    'assembly=s'   => \$fi_consensus,
    'homopolish=s' => \$fi_homopolish,
    #-outputs----------------------------------------------------------------#
    'out=s' => \$fo_consensus,
    #-knobs------------------------------------------------------------------#
    'threads=i'        => \$threads,
    'n_racon=i'        => \$n_racon,
    'n_medaka=i'       => \$n_medaka,
    'min_cov=i'        => \$min_cov,
    'min_len=i'        => \$min_len,
    'mask_below=i'     => \$mask_below,
    'split_below=i'    => \$split_below,
    'hp_model=s'       => \$hp_model,
    'medaka_model=s'   => \$med_model,
    'only_split_at_hp' => \$only_split_at_hp,
    'quiet'            => \$quiet,
    'help'             => sub{ pod2usage(-verbose => 2); },
    'version'          => sub{ print "This is $PROGRAM v$VERSION\n";exit; },

) or pod2usage( -verbose => 1);

# check for required software
my $MINIMAP2 = can_run('minimap2')
    // die "Minimap2 is required but not found\n";

my $MINIASM = can_run('miniasm');
if (! defined $fi_consensus && ! defined $MINIASM) {
    die "Miniasm is required but not found\n";
}

my $RACON = can_run('racon');
if ($n_racon > 0 && ! defined $RACON) {
    die "Racon is required but not found\n";
}

my $MEDAKA = can_run('medaka_consensus');
if ($n_medaka > 0 && ! defined $MEDAKA) {
    die "Medaka is required but not found\n";
}

my $SAMTOOLS = can_run('samtools');
if ((defined $mask_below || defined $split_below) && ! defined $SAMTOOLS) {
    die "Samtools is required but not found\n";
}

my $BEDTOOLS = can_run('bedtools');
if ((defined $mask_below || defined $split_below) && ! defined $BEDTOOLS) {
    die "Bedtools is required but not found\n";
}

my $HOMOPOLISH = can_run('homopolish');
if (defined $fi_homopolish && ! defined $HOMOPOLISH) {
    die "Homopolish is required but not found\n";
}

# globals

die "Must define existing input file (--in)\n"
    if (! defined $fi_reads || ! -r $fi_reads);
$fi_reads = abs_path($fi_reads);

if (defined $fi_consensus) {
    die "Input assembly not found or readable\n"
        if (! -r $fi_consensus);
    $fi_consensus = abs_path($fi_consensus);
}

if (defined $fi_homopolish) {
    die "Homopolish reference not found or readable\n"
        if (! -r $fi_homopolish);
    $fi_homopolish = abs_path($fi_homopolish);
}

if (defined $fo_consensus) {
    $fo_consensus = abs_path($fo_consensus);
}

# work in scratch space
my $init_dir = abs_path(getcwd());
my $in_base = basename($fi_reads);
my $wd =  File::Temp->newdir(CLEANUP => 1);
chdir $wd;
symlink $fi_reads, $in_base;

my $curr_cons = 'init.fa';

# initial assembly
if (defined $fi_consensus) {
    copy $fi_consensus, $curr_cons;
    plog( 'assembly', "Using provided assembly" );
}
else {
    plog( 'assembly', 'Initial assembly with miniasm' );
    my $ts = time;
    map_ava( $in_base, 'init.paf' );
    miniasm( $in_base, 'init.paf', $curr_cons );
    my $el = time - $ts;
    plog( 'assembly', "Assembly took $el s" );
}

# bail out gracefully if initial assembly is empty
if (! -s $curr_cons) {
    plog( 'assembly', "Initial assembly empty, skipping polishing" );
    if (defined $fo_consensus) {
        copy $curr_cons, $fo_consensus;
    }
    chdir $init_dir;
    exit;
}

# racon polishing
plog( 'racon', "Polishing with racon ($n_racon rounds total)" );
for my $i (1..$n_racon) {
    my $new_cons = "rc$i.fa";

    my $ts = time;
    polish_racon( $in_base, $curr_cons, $new_cons);
    my $el = time - $ts;
    plog( 'racon', "Round took $el s" );

    $curr_cons = $new_cons;
}

if (defined $fi_homopolish) {

    # homopolishing
    plog( 'homopolish', "Polishing with homopolish" );
    my $new_cons = "hp.fa";

    my $ts = time;
    homopolish( $fi_homopolish, $curr_cons, $new_cons);
    my $el = time - $ts;
    plog( 'homopolish', "Took $el s" );

    $curr_cons = $new_cons;

}

# medaka polishing
plog( 'medaka', "Polishing with medaka ($n_medaka rounds total)" );
for my $i (1..$n_medaka) {

    my $new_cons = "md$i.fa";

    my $ts = time;
    polish_medaka( $in_base, $curr_cons, $new_cons);
    my $el = time - $ts;
    plog( 'medaka', "Round took $el s" );

    $curr_cons = $new_cons;
}

if (defined $split_below) {

    plog( 'split', "Splitting at regions with coverage below $split_below" );
    my $new_cons = "split.fa";

    my $ts = time;
    split_below($in_base, $curr_cons, $new_cons, $split_below);
    my $el = time - $ts;
    plog( 'split', "Splitting took $el s" );

    $curr_cons = $new_cons;

}

if (defined $mask_below) {

    plog( 'mask', "Masking regions with coverage below $mask_below" );
    my $new_cons = "mask.fa";

    my $ts = time;
    mask_below($in_base, $curr_cons, $new_cons, $mask_below);
    my $el = time - $ts;
    plog( 'mask', "Masking took $el s" );

    $curr_cons = $new_cons;

}

#always run this, and run it last, since we rename the contigs as well
if (1) {

    plog( 'filter', "Filtering contigs shorter than $min_len" );
    my $new_cons = "filtered.fa";

    my $ts = time;
    filter_short($curr_cons, $new_cons, $min_len);
    my $el = time - $ts;
    plog( 'filter', "Filtering took $el s" );

    $curr_cons = $new_cons;

}

# copy to final location
open my $in, '<', $curr_cons;
my $fh_out = \*STDOUT;
if (defined $fo_consensus) {
    open my $fh, '>', $fo_consensus;
    $fh_out = $fh;
}
while (my $line = <$in>) {
    print {$fh_out} $line;
}

chdir $init_dir;
exit;

# minimap2 -ax map-ont trim.fa trimmed.fq > rc.sam
# racon -m 8 -x -6 -g -8 -w 500 --no-trimming trimmed.fq rc.sam trim.fa > rc.fa

# minimap2 -x ava-ont trimmed.fq trimmed.fq > trim.paf
sub map_ava {
    
    my ($fi, $fo) = @_;

    my @cmd = (
        $MINIMAP2,
        '-t' => $threads,
        '-x' => 'ava-ont',
        '-o' => $fo,
        $in_base,
        $in_base,
    );
    run( command => \@cmd )
        or die "Initial AVA mapping failed: $!";
}

sub split_below {
    
    my ($fi_reads, $fi_cons, $fo_cons, $split_below) = @_;

    # map reads against existing consensus
    # minimap2 -ax map-ont trim.fa trimmed.fq > rc.sam
    my @cmd_mm = (
        $MINIMAP2,
        '-t' => $threads,
        '-a',
        '-x' => 'map-ont',
        '-o' => 'split.sam',
        $fi_cons,
        $fi_reads,
    );
    run( command => \@cmd_mm )
        or die "consensus read mapping failed: $!";

    my @cmd_sort = (
        $SAMTOOLS,
        'sort',
        '--threads' => $threads,
        '-o' => 'sorted.bam',
        'split.sam',
    );
    run( command => \@cmd_sort )
        or die "SAM sorting failed: $!";


    my @cmd_cov = (
        $BEDTOOLS,
        'genomecov',
        '-ibam' => 'sorted.bam',
        '-split',
        '-bga',
    );
    my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf )
        = run( command => \@cmd_cov );
    die "Error running bedtools genomecov: $error_message"
        if (! $success);

    my %split_points;
    # this hack is necessary to process output by line; otherwise buffering can
    # cause incomplete lines to be processed
    my $stdout = join '', @{ $stdout_buf};
    open my $stream, '<', \$stdout;
    while (my $line = <$stream>) {
        chomp $line;
        my @fields = split "\t", $line;
        next if ($fields[3] >= $split_below);
        push @{ $split_points{$fields[0]} }, [$fields[1]+1, $fields[2]];
    }
    close $stream;

    open my $out, '>', $fo_cons;

    my $p = BioX::Seq::Stream->new($fi_cons);
    CHR:
    while (my $seq = $p->next_seq) {

        my $chr = $seq->id;
        my @points = defined $split_points{$chr}
            ? @{ $split_points{$chr} }
            : ();
        if ($only_split_at_hp) {
            my @new;
            my $win = 5;
            for my $p (@points) {
                my $hp = 0;
                for (@$p) {
                    my $l = $_ > $win ? $_-$win : 1;
                    my $r = length($seq) - $_ > $win ? $_+$win : length($seq);
                    my $s = $seq->range($l, $r);
                    ++$hp if ($s->seq =~ /(\w)(\1{3,})/);
                }
                push @new, $p if ($hp > 0);
            }
            @points = @new;
        }
        if (! scalar @points) {
            print {$out} $seq->as_fasta;
            next CHR;
        }
        my $i = 1;
        for my $p (@points) {
            if ($p->[0] >= $i) {
                my $sub = $seq->range($i, $p->[0]-1);
                my $l = length $sub;
                $sub->desc =~ s/\bLN:i:\d+\b/LN:i:$l/;
                print {$out} $sub->as_fasta;
            }
            $i = $p->[1] + 1;
        }
        if ($i <= length($seq)) {
            my $sub = $seq->range($i, length($seq));
            my $l = length $sub;
            $sub->desc =~ s/\bLN:i:\d+\b/LN:i:$l/;
            print {$out} $sub->as_fasta;
        }

    }
            
    close $out;

}
    

sub miniasm {
    
    my ($fi_reads, $fi_paf, $fo) = @_;

    my @cmd = (
        $MINIASM,
        '-s' => '200',
        '-c' => $min_cov,
        '-e' => 1,
        '-I' => '0.2',
        '-f' => $fi_reads,
        $fi_paf,
    );
    #open my $stream, '-|', @cmd;
    my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf )
        = run( command => \@cmd );
    die "Error running miniasm: $error_message"
        if (! $success);

    # convert GFA to FASTA
    open my $out, '>', $fo;
    # this hack is necessary to process output by line; otherwise buffering can
    # cause incomplete lines to be processed
    my $stdout = join '', @{ $stdout_buf};
    open my $stream, '<', \$stdout;
    while (my $line = <$stream>) {
        chomp $line;
        my @fields = split "\t", $line;
        next if ($fields[0] ne 'S');
        print {$out} BioX::Seq->new(
            $fields[2],
            $fields[1],
            $fields[3],
        )->as_fasta;
    }
    close $out;
    close $stream;

}

sub polish_racon {
    
    my ($fi_reads, $fi_cons, $fo_cons) = @_;

    # map reads against existing consensus
    # minimap2 -ax map-ont trim.fa trimmed.fq > rc.sam
    my @cmd_mm = (
        $MINIMAP2,
        '-t' => $threads,
        '-a',
        '-x' => 'map-ont',
        '-o' => 'rc.sam',
        $fi_cons,
        $fi_reads,
    );
    run( command => \@cmd_mm )
        or die "consensus read mapping failed: $!";

    # call new consensus with Racon
    # racon -m 8 -x -6 -g -8 -w 500 --no-trimming trimmed.fq rc.sam trim.fa > rc.fa
    my @cmd_rc = (
        $RACON,
        '--threads'       => $threads,
        '--match'         => 8,
        '--mismatch'      => '-6',
        '--gap'           => '-8',
        '--window-length' => 500,
        '--no-trimming',
        $fi_reads,
        'rc.sam',
        $fi_cons
    );
    
    my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf )
        = run( command => \@cmd_rc );
    die "Error running racon: $error_message"
        if (! $success);

    open my $out, '>', $fo_cons;
    # this hack is necessary to process output by line; otherwise buffering can
    # cause incomplete lines to be processed
    my $stdout = join '', @{ $stdout_buf};
    open my $stream, '<', \$stdout;
    while (my $line = <$stream>) {
        print {$out} $line;
    }
    close $out;
    close $stream;

}

# medaka_consensus -i trimmed.fq -d rc2.fa -o polished
sub polish_medaka {

    my ($fi_reads, $fi_cons, $fo_cons) = @_;

    my @cmd = (
        $MEDAKA,
        '-t' => $threads,
        '-f',
        '-i' => $fi_reads,
        '-d' => $fi_cons,
        '-o' => 'polished',
    );
    if (defined $med_model) {
        push @cmd, '-m' => $med_model;
    }
    run( command => \@cmd )
        or die "Call to medaka failed: $!";

    # transfer annotations dropped by Medaka
    transfer_annots(
        $fi_cons,
        'polished/consensus.fasta',
        $fo_cons
    );

}

sub transfer_annots {

    my ($fn_old, $fn_new, $fn_out, $strip_suffix) = @_;

    open my $fh_out, '>', $fn_out;

    # read annotations from input contigs
    my %annots;
    my $p = BioX::Seq::Stream->new($fn_old);
    while (my $seq = $p->next_seq) {
        $annots{$seq->id} = $seq->desc // '';
    }
    # copy annotations to output contigs
    $p = BioX::Seq::Stream->new($fn_new);
    while (my $seq = $p->next_seq) {
        my $id = $seq->id;
        if (defined $strip_suffix) {
            $id =~ s/$strip_suffix$//;
            $seq->id = $id;
        }
        my $tags = $annots{$id}
            // die "Missing annotations for contig " . $id;
        my $l = length $seq;
        $tags =~ s/\bLN:i:\d+\b/LN:i:$l/;
        $seq->desc = join ' ',
            grep {defined $_ && length $_} $seq->desc, $tags;
        print {$fh_out} $seq->as_fasta;
    }

    close $fh_out;

}

sub mask_below {
    
    my ($fi_reads, $fi_cons, $fo_cons, $min_depth) = @_;

    # map reads against existing consensus
    # minimap2 -ax map-ont trim.fa trimmed.fq > rc.sam
    my @cmd_mm = (
        $MINIMAP2,
        '-t' => $threads,
        '-a',
        '-x' => 'map-ont',
        '-o' => 'mask.sam',
        $fi_cons,
        $fi_reads,
    );
    run( command => \@cmd_mm )
        or die "consensus read mapping failed: $!";

    my @cmd_sort = (
        $SAMTOOLS,
        'sort',
        '--threads' => $threads,
        '-o' => 'sorted.bam',
        'mask.sam',
    );
    run( command => \@cmd_sort )
        or die "SAM sorting failed: $!";

    my @cmd_cov = (
        $BEDTOOLS,
        'genomecov',
        '-ibam' => 'sorted.bam',
        '-split',
        '-bga',
    );
    my ( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf )
        = run( command => \@cmd_cov );
    die "Error running bedtools genomecov: $error_message"
        if (! $success);

    open my $out, '>', 'mask.bed';
    # this hack is necessary to process output by line; otherwise buffering can
    # cause incomplete lines to be processed
    my $stdout = join '', @{ $stdout_buf};
    open my $stream, '<', \$stdout;
    while (my $line = <$stream>) {
        chomp $line;
        my @fields = split "\t", $line;
        next if ($fields[3] >= $min_depth);
        say {$out} $line;
    }
    close $out;
    close $stream;

    # mask consensus
    my @cmd_mask = (
        $BEDTOOLS,
        'maskfasta',
        '-fi' => $fi_cons,
        '-bed' => 'mask.bed',
        '-fo' => $fo_cons,
    );
    run( command => \@cmd_mask )
        or die "Error running bedtools maskfasta: $!";

}

sub filter_short {
    
    my ($fi_cons, $fo_cons, $min_len) = @_;

    my $p = BioX::Seq::Stream->new($fi_cons);
    my @final;
    while (my $seq = $p->next_seq) {
        next if (length $seq < $min_len);
        push @final, $seq;
    }

    my $padding = length (scalar @final - 1);
    my $i = 0; 
    open my $out, '>', $fo_cons;
    for my $ctg (sort {length($b) <=> length($a)} @final) {
        $ctg->id = sprintf "ctg_%0${padding}s", $i++;
        print {$out} $ctg->as_fasta;
    }
    close $out;

}

sub homopolish {
    
    my ($fi_ref, $fi_cons, $fo_cons) = @_;

    my @cmd_hp = (
        $HOMOPOLISH,
        'polish',
        '-a' => $fi_cons,
        '-l' => $fi_ref,
        '-m' => $hp_model,
        '--minimap_args' => 'map-ont',
        '-o' => 'hp',
    );
    run( command => \@cmd_hp )
        or die "homopolish failed: $!";

    my $basename = basename($fi_cons);
    $basename =~ s/\..*//;
    my $hp_out = "hp/${basename}_homopolished.fasta";
    die "Missing homopolish output file\n"
        if (! -e $hp_out);

    # transfer annotations dropped by homopolish
    transfer_annots(
        $fi_cons,
        $hp_out,
        $fo_cons,
        '_polish',
    );

}

sub plog {

    my ($unit, $msg) = @_;
    return if ($quiet);
    say STDERR "[mm::$unit] $msg";

}

__END__

=head1 NAME

minimeta - assembler for long-read metagenomic/metatranscriptomic data sets

=head1 SYNOPSIS

minimeta --in <reads.fq> --out <consensus.fasta>

=head1 DESCRIPTION

Produced a polished consensus assembly from long-read reads using miniasm,
racon, and medaka. Software settings are tuned for
metagenomic/metatranscriptomic assemblies of variable, sometimes low,
coverage.

=head1 PREREQUISITES

Requires the following non-core Perl libraries:

=over 1

=item * BioX::Seq

=back

as well as the following binaries:

=over 1

=item * minimap2

=item * miniasm

=item * racon

=item * medaka

=item * samtools

=item * bcftools

=back

=head1 OPTIONS

=head2 Input

=over 4

=item B<--in> I<filename>

Path to input reads in FASTx format (required)

=item B<--assembly> I<filename>

Path to existing assembly. If provided, assembly is skipped and only polishing
is performed (default: none).

=item B<--homopolish> I<filename>

Path to reference FASTA file used by homopolish. Providing this filename also
triggers polishing using homopolish (default: none).

=back

=head2 Output 

=over 4

=item B<--out> I<filename>

Path to write consensus sequence to (as FASTA) [default: STDOUT]

=back

=head2 Configuration 

=over 4

=item B<--min_cov> I<integer>

Minimum read coverage required by assembler to keep position (default: 2)

=item B<--min_len> I<integer>

Minimum contig length to keep (default: 1)

=item B<--mask_below> I<integer>

If given, final assembly positions with coverage depth below this value will
be hard masked with 'N' (default: off)

=item B<--split_below> I<integer>

If given, contigs will be split at regions with coverage lower than this depth
(default: off)

=item B<--only_split_at_hp>

If given in conjuction with C<--split_below>, only splits low coverage regions
if one or both junctions is at a homopolymer stretch
(default: off)

=item B<--threads> I<integer>

Number of processsing threads to use for mapping and polishing (default: 1)

=item B<--n_racon> I<integer>

Number of Racon polishing rounds to perform (default: 3)

=item B<--n_medaka> I<integer>

Number of Medaka polishing rounds to perform (default: 1)

=item B<--hp_model> I<string>

Name of model to be used by homopolish. Has no effect if B<--homopolish> not
used (default: R9.4.pkl).

=item B<--quiet>

Don't write status messages to STDERR

=item B<--help>

Print usage description and exit

=item B<--version>

Print software version and exit

=back

=head1 CAVEATS AND BUGS

Please submit bug reports to the issue tracker in the distribution repository.

=head1 AUTHOR

Jeremy Volkening (jeremy.volkening@base2bio.com)

=head1 LICENSE AND COPYRIGHT

Copyright 2021 Jeremy Volkening

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

